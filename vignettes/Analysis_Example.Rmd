---
title: "ScreenR Example Analysis"
output: BiocStyle::html_document
author:
- name: "Emanuel Michele Soda "
  affiliation: Istituto Europeo Oncologia (IEO),
               Milano, Italy
  email: emanuelmichele@ieo.it or emanuelsoda@gmail.com
package: ScreenR  
vignette: >
  %\VignetteIndexEntry{ScreenR Example Analysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::knitr}
editor_options: 
  chunk_output_type: console
---

# Importing Pacakge
```{r packages, message=FALSE, warning=TRUE}
library(ggplot2)
library(dplyr)
library(tidyr)
knitr::opts_chunk$set(fig.width = 6, fig.height = 4)
```

# Introduction 
The R package **ScreenR** has been developed to perform the analysis of data 
coming from RNA-seq data generated using Genetic Screening. It is based 
on the same idea of edgeR but it also integrate the idea at the base of 
Tidyverse. 

# Installation {#installation}

## Bioconductor

**ScreenR** requires several CRAN and Bioconductor R packages to be
installed. Dependencies are usually handled automatically, when installing the
package using the following commands:

```{r ScreenR install Bioc, eval=FALSE, message=FALSE, warning=TRUE}
install.packages("BiocManager")
BiocManager::install("ScreenR")
```

## Manual installation

In the unlikely case that a manual installation is required, e.g., if you do
not install **ScreenR** via Bioconductor (which is highly recommended),
you can install CRAN pacakges using: 

```{r pkg install, eval=FALSE, message=FALSE, warning=TRUE}
install.packages("<package_name>")
```

While Bioconductor packages can be installed from R using the following command:

```{r pkg bioc install, eval=FALSE, message=FALSE, warning=TRUE}
BiocManager::install("<package_name>")
```

Sometimes, it may also be useful to update Bioconductor:

```{r bioc update, eval=FALSE, message=FALSE, warning=TRUE}
BiocManager::install()
```

Finally, the manual installation of **ScreenR** can, for example, be
done from the command line ...

```{r manual install, eval=FALSE, message=FALSE, warning=TRUE}
R CMD INSTALL ScreenR_<version>.tar.gz
```

... or the newest version can directly be installed from GitHub using the
CRAN package devtools:

```{r github install, eval=FALSE, message=FALSE, warning=TRUE}
# install.packages("devtools")
devtools::install_github("EmanuelSoda/ScreenR")
```


# Analysis 
Here is reported an example of the ScreenR pipeeline
<img src="/Users/ieo5571/Documents/IEO/Stage/ScreenR/man/figures/Pipeline.png" align="top">

## Loading the package

After installation, loading the package is simple as :
```{r, message=FALSE, warning=TRUE}
library(ScreenR)
```

## Read Data
The input of ScreenR is a count table. A count table is usually the starting 
point  of an RNA-seq differentially expressed genes analysis and consists of
a matrix containing  reads count organized with: 

* Genes on the rows
* Samples on the columns

For this vignette we will use as an example a Loss of Function Genetic Screening
performed using . 
First of all the data has to be read.
```{r read_data, message=FALSE, warning=TRUE}
data(count_table)
data(annotation_table)

data <- count_table
colnames(data) <- c(
    "Barcode", "Time1", "Time2", "Time3_TRT_A", "Time3_TRT_B", "Time3_TRT_C",
    "Time3_CTRL_A", "Time3_CTRL_B", "Time3_CTRL_C", 
    "Time4_TRT_A", "Time4_TRT_B", "Time4_TRT_C", 
    "Time4_CTRL_A", "Time4_CTRL_B", "Time4_CTRL_C"
)
data <- data %>%
    dplyr::mutate(Barcode = as.factor(Barcode)) %>%
    dplyr::filter(Barcode != "*")


total_Annotation <- annotation_table
```

## Object Creation 
The second needed step is to create a **ScreenR object** from the count table.
The ScreenR object is created using the function **create_screenR_object()**.
This object will be used to store the most important information to perform 
the analysis. Most of the ScreenR function takes as main input the ScreenR 
object to perform the needed operation and return a result.

```{r Create_Object, message=FALSE, warning=TRUE}
groups <- factor(c(
    "T1/T2", "T1/T2",
    "Time3_TRT", "Time3_TRT", "Time3_TRT",
    "Time3_CTRL", "Time3_CTRL", "Time3_CTRL",
    "Time4_TRT", "Time4_TRT", "Time4_TRT",
    "Time4_CTRL", "Time4_CTRL", "Time4_CTRL"
))

palette <- c(
    "#66c2a5", "#fc8d62", rep("#8da0cb", 3),
    rep("#e78ac3", 3),
    rep("#a6d854", 3),
    rep("#ffd92f", 3)
)

object <- create_screenr_object(
    table = data, annotation = total_Annotation, groups = groups,
    replicates = ""
)
```

## Removing all zero rows

```{r Removing all zero rows, message=FALSE, warning=TRUE}
object <- remove_all_zero_row(object)
```


## Computing the needed tables
In order to start the analysis the data has first to be normalized and the 
*data_table*.

For what concern the normalizzation ScreenR uses a normalizzation that is 
called *Counts Per Million (CPM)* which has the following mathematical 
expression:

$$CPM = \frac{Number \; of \; mapped \; reads \; to \; a \; barcode} 
             { \sum_{sample}{Number\; of \;mapped \; reads}} *10^{6}$$ 
                   
The number of reads mapped for each Barcode in a sample are normalized by the 
number of reads in that sample and multiplied by one million.
Then has to be computed the *data_table*. The *data_table* can be seen as a 
tidy version of the original *count table* and will be used throughout the 
analysis.
```{r normalizzation, message=FALSE, warning=TRUE}
object <- normalize_data(object)
object <- compute_data_table(object)
```


## Mapped Reads
```{r plot_mapped_reads, message=FALSE, warning=TRUE}
plot <- plot_mapped_reads(object, palette) +
    ggplot2::coord_flip() +
    ggplot2::scale_y_continuous(labels = scales::comma) +
    ggplot2::theme(legend.position = "none") +
    ggplot2::ggtitle("Number of Mapped Reads in each sample")

plot
```

## Quality Check 
The first step to perform when dealing with RNA-seq data is to check the 
quality of the samples. In ScreenR this can be done using several methods.
For example the distribution can be seen using both boxplots or density plots.

### Boxplot Mapped Reads
```{r  plot_mapped_reads_distribution_boxplot, message=FALSE, warning=TRUE}
plot <- plot_mapped_reads_distribution(
    object, palette,
    alpha = 0.8,
    type = "boxplot"
) +
    coord_flip() +
    theme(legend.position = "none") 

plot
```

### Density plot
```{r  plot_mapped_reads_distribution_density, message=FALSE, warning=TRUE}
plot <- plot_mapped_reads_distribution(
    object, palette,
    alpha = 0.5,
    type = "density"
) +
    ggplot2::theme(legend.position = "none") 

plot
```


### Barcode Lost

Moreover another very important quality check when a Genetic Screening is 
performed is to check the barcode lost during the experiment. ScreenR implements
a function able to  compute and plot the number of barcodes lost. 
```{r  plot_barcode_lost, message=FALSE, warning=TRUE}
plot <- plot_barcode_lost(screenR_Object = object, palette = palette) +
    ggplot2::coord_flip()
plot
```

### Plot MDS {.tabset}
In order to see compare the samples an initial MDS analysis can be conducted.
In ScreenR this can be done using the *plot_mds* function as follow.

#### For Sample
```{r  Plot_MDS_Sample, message=FALSE, warning=TRUE}
plot_mds(screenR_Object = object)
```


#### For Treatment
```{r  Plot_MDS_Treatment, message=FALSE, warning=TRUE}
group_table <- get_data_table(object)   %>%
    select(Sample, Day, Treatment) %>%
    distinct()

group_treatment <- group_table$Treatment

plot_mds(
    screenR_Object = object,
    groups = factor(x = group_treatment, levels = unique(group_treatment))
)
```

#### For Day
```{r  Plot_MDS_Day, message=FALSE, warning=TRUE}
group_day <- group_table$Day

plot_mds(
    screenR_Object = object,
    groups = factor(x = group_day, levels = unique(group_day))
)
```

## Statistical Analysis
Finally can be conducted the real analysis. 
The statistical Analysis is based on three methods:

* Z-score filtering
* CAMERA filtering 
* ROAST filtering 

### Compute Metrics
In order to compute the Z-score, first a list of metrics has to be computed. 
In particular a *Log2FC* is computed for the treated vs control samples in the 
different conditions. Here for example a treated vs control in different day 
is computed. Then the different distribution of the Z-score can be plotted 
using the *plot_zscore_distribution* function. 

```{r  compute_metrics, message=FALSE, warning=TRUE}
# 2DG
data_with_measure_TRT <- list(
    Time3 = compute_metrics(
        object,
        control = "CTRL", treatment = "TRT",
        day = "Time3"
    ),
    Time4 = compute_metrics(
        object,
        control = "CTRL", treatment = "TRT",
        day = "Time4"
    )
)

plot_zscore_distribution(data_with_measure_TRT, alpha = 0.8) 
```


### Z-score hit
Now that the metrics has been computed the hits according to Z-score can be 
found. This in ScreenR is done using the *find_zscore_hit* function.

```{r  Z_score_hit, message=FALSE, warning=TRUE}
zscore_hit_TRT <- list(
    Time3 = find_zscore_hit(
        table_treate_vs_control = data_with_measure_TRT$Time3,
        number_barcode = 6, metric = "median"
    ),
    Time4 = find_zscore_hit(
        table_treate_vs_control = data_with_measure_TRT$Time4,
        number_barcode = 6, metric = "median"
    )
)
zscore_hit_TRT
```   


### CAMERA
The same can be done with the CAMERA hit using the function *find_camera_hit*.
```{r  CAMERA, message=FALSE, warning=TRUE}
matrix_model <- model.matrix(~ groups)
colnames(matrix_model) <- unique(groups)


camera_hit_TRT <- list(
    Time3 = find_camera_hit(
        screenR_Object = object, matrix_model = matrix_model,
        contrast = "Time3_TRT",
    ),
    Time4 = find_camera_hit(
        screenR_Object = object, matrix_model = matrix_model,
        contrast = "Time4_TRT"
    )
)

camera_hit_TRT
```

### ROAST
Last but not least this is done also for the ROAST hit using the function  
*find_roast_hit*.
```{r ROAST, message=FALSE, warning=TRUE}
roast_hit_TRT <- list(
    Time3 = find_roast_hit(
        screenR_Object = object, matrix_model = matrix_model,
        contrast = "Time3_TRT", 
    ),
    Time4 = find_roast_hit(
        screenR_Object = object, matrix_model = matrix_model,
        contrast = "Time4_TRT"
    )
)

roast_hit_TRT
```


### Find Common Hit 
ScreenR consider as final hit only the one present in common among the three 
methods. In particular two strategy are possible:

* Are considered candidate Hits the one present in at least two of the three 
methods
* Are considered candidate Hits the one present in all of the three methods


```{r Common_Hit,  message=FALSE, warning=TRUE}
common_hit_TRT_at_least_2 <- list(
    Time3 = find_common_hit(
        zscore_hit_TRT$Time3, camera_hit_TRT$Time3, roast_hit_TRT$Day3,
        common_in = 2
    ),
    Time4 = find_common_hit(
        zscore_hit_TRT$Time4, camera_hit_TRT$Time4, roast_hit_TRT$Day6,
        common_in = 2
    )
)

common_hit_TRT_at_least_3 <- list(
    Time3 = find_common_hit(
        zscore_hit_TRT$Time3, camera_hit_TRT$Time3, roast_hit_TRT$Time3,
        common_in = 3
    ),
    Time4 = find_common_hit(
        zscore_hit_TRT$Time4, camera_hit_TRT$Time4, roast_hit_TRT$Time4,
        common_in = 3
    )
)
```

### Plot common hit

The hits can be easily visualized using the *plot_common_hit* function.

```{r Venn_diagram_in_at_least_2}
plot_common_hit(
    hit_zscore = zscore_hit_TRT$Time4, hit_camera = camera_hit_TRT$Time4,
    roast_hit_TRT$Time4, show_elements = FALSE, show_percentage = TRUE
)
```



We can visualize the trend of the hits found using the function *plot_trend*.

```{r plot_trend}
candidate_hits <- common_hit_TRT_at_least_2$Time3

plot_trend(screenR_Object = object, 
           genes = candidate_hits[1:4], 
           nrow = 2, ncol = 2, 
           group_var = c("Time1", "Time2", "TRT"))

plot_trend(screenR_Object = object, 
           genes = candidate_hits[5:6], 
           ncol = 2, group_var = c("Time1", "Time2", "TRT"))
```


```{r}
sessionInfo()
```
